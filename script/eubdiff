#!/usr/bin/perl

use strict;
use warnings;

use Archive::Eubar;
use Fcntl qw(:mode);

usage() if !@ARGV;
my $ar = Archive::Eubar->new(shift);
my $h = $ar->metadata;

while (defined(my $path = <STDIN>)) {
    next if $path !~ s{[^/]*(?=/)}{};
    chomp $path;
    my $arf = delete $h->{$path};
    my @stat = lstat $path;
    if (!defined $arf) {
        # It's a new file
        next if !@stat;
        print '+', stat2file($path, @stat)->meta, "\n";
    }
    elsif (!@stat) {
        # File has been deleted or moved
        print '-', $arf->type, ' ', $arf->path, "\n";
    }
    elsif ((my $fsmeta = stat2file($path, @stat)->meta) ne $arf->meta) {
        print '+', $fsmeta, "\n";
    }
    else {
        print '=', typechar($stat[2]), ' ', $path, "\n";
    }
}

foreach (sort keys %$h) {
    my $arf = $h->{$_};
    print '-', $arf->type, ' ', $arf->path, "\n";
}

sub typechar {
    my ($mode) = @_;
    return S_ISREG($mode)  ? 'f' :
           S_ISDIR($mode)  ? 'd' :
           S_ISLNK($mode)  ? 'l' :
           S_ISBLK($mode)  ? 'b' :
           S_ISCHR($mode)  ? 'c' :
           S_ISFIFO($mode) ? 'p' :
           S_ISSOCK($mode) ? 's' : '?';
}

sub stat2file {
    my $path = shift;
    my $mode = $_[2];
    my $type = typechar($mode);
    my %f = (
        'a' => '+',
        't' => $type,
        '/' => $path,
        'd' => $_[0],
        'i' => $_[1],
        'p' => $mode,
        'u' => $_[4],
        'g' => $_[5],
        'r' => $_[6],
        'm' => $_[9],
        'c' => $_[10],
    );
    if ($type eq 'f' || $type eq 'l') {
        $f{'*'} = $_[7];
    }
    $ar->file(%f);
}
